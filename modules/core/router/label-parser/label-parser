#!/usr/bin/env python

# Usage:
# docker container run --rm localhost:5000/label-parser docker-compose.yml

# input: docker-compose.yml with swarmlet labels
# output: docker-compose.yml with traefik labels

# example swarmlet labels:
# - swarmlet.port=9000
# - swarmlet.domains=mysite.com,www.mysite.com
# - swarmlet.letsencrypt.email=mail@domain.com
# (optional labels):
# - swarmlet.enabled=true  # default to true if a swarmlet label is detected
# - swarmlet.protocols=http,https
# - swarmlet.middlewares=redirect@file,auth@file
# - swarmlet.middlewares=redirect-https,basic-auth ???

# example output traefik labels:
# - traefik.enable=true
# - traefik.http.services.my-service.loadbalancer.server.port=9000
# - traefik.http.routers.my-service.rule=Host(`mysite.com`) || Host(`www.mysite.com`)
# - traefik.http.routers.my-service.entrypoints=http,https
# - traefik.http.routers.my-service.middlewares=redirect@file

import sys
import re
import yaml
import itertools


class Labels:
    def __init__(self, service_name, deploy_labels):
        self.service_name = service_name
        self.deploy_labels = deploy_labels
        self.new_labels = {}
        self.default_labels = {
            'enable': ['traefik.enable=true'],
            'middlewares': ['traefik.http.routers.%s.middlewares=redirect@file' % (
                self.service_name,
            )],
            'entrypoints': ['traefik.http.routers.%s.entrypoints=%s' % (
                self.service_name,
                'http,https',
            )],
        }
        self.labels = {
            'domains': lambda domains: [y for y in [
                'traefik.http.routers.%s.rule=%s' % (
                    self.service_name,
                    ' || '.join(['Host(`%s`)' %
                                 x for x in domains.split(',')]),
                ),
                self.set_label('letsencrypt.domains', domains),
            ] if y],
            'port': lambda port: ['traefik.http.services.%s.loadbalancer.server.port=%s' % (
                self.service_name,
                port,
            )],
            'entrypoints': lambda entrypoints: ['traefik.http.routers.%s.entrypoints=%s' % (
                self.service_name,
                entrypoints,
            )],
            'middlewares': lambda middlewares: ['traefik.http.routers.%s.middlewares=%s' % (
                self.service_name,
                middlewares,
            )],
            'letsencrypt.domains': lambda domains: [
                'traefik.http.routers.%s.tls=true' % self.service_name,
                'traefik.http.routers.%s.tls.certresolver=letsencrypt' % self.service_name,
                'traefik.http.routers.%s.tls.domains[0].main=%s' % (
                    self.service_name,
                    ','.join(
                        [x for x in filter(lambda x: re.match(r'[a-z]+\.[a-z]+$', x), domains.split(','))]),
                ),
                'traefik.http.routers.%s.tls.domains[0].sans=%s' % (
                    self.service_name,
                    ','.join(
                        [x for x in filter(lambda x: re.match(r'([a-z]+\.){2,}[a-z]+$', x), domains.split(','))]),
                ),
            ],
            'letsencrypt.email': lambda email: ['traefik.http.routers.%s.middlewares=%s' % (
                self.service_name,
                middlewares,
            )],
        }
        self.create_labels()

    def create_labels(self):
        for label_key in self.labels.keys():
            label_value = re.sub(r'.*=', '', ''.join(
                filter(lambda label: '.%s=' % label_key in label, self.deploy_labels)))
            if len(label_value):
                self.set_label(label_key, label_value)

    def set_label(self, label_key, label_value):
        self.new_labels[label_key] = self.labels[label_key](label_value)

    def get_labels(self):
        return list({**self.default_labels, **self.new_labels}.values())


def parse_labels(compose_file):
    """Parse Swarmlet deployment labels and return new Docker Compose file"""
    with open(compose_file) as f:
        sections = yaml.load(f, Loader=yaml.FullLoader)
        new_sections = {}

        if sections.get('services') is None:
            raise AttributeError

        for service_name in sections.get('services').keys():
            service = sections.get('services').get(service_name)

            if service.get('deploy') is not None:
                deploy_labels = service.get('deploy').get('labels')

                if (
                    deploy_labels is None
                    or 'traefik.' in '\t'.join(deploy_labels)
                    or 'swarmlet.' not in '\t'.join(deploy_labels)
                ):
                    continue

                new_deploy_labels = Labels(service_name, deploy_labels)

                service['deploy']['labels'] = list(
                    itertools.chain(*new_deploy_labels.get_labels()))

                if 'services' not in new_sections:
                    new_sections['services'] = {}

                new_sections['services'][service_name] = service

        for section_type in new_sections.keys():
            for section_name in new_sections[section_type].keys():
                sections[section_type][section_name] = new_sections[section_type][section_name]

        return yaml.dump(sections)

        # with open('docker-compose.swarmlet.yml', 'w') as f:
        #     sections = yaml.dump(sections, f)

    # return yml with updated labels


if __name__ == "__main__":
    input = sys.argv[1]
    output = parse_labels(input)
    print(output)
